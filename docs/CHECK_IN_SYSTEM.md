# Check-In System Documentation

## Overview

The Attenda check-in system allows event organizers to verify and check in attendees by scanning their ticket QR codes. The system uses verification codes embedded in the encrypted ticket metadata to ensure authenticity.

## How It Works

### 1. Ticket Creation & QR Code Generation

When a ticket is minted, the system:

1. Generates a unique **verification code** (8-character alphanumeric string)
2. Creates a QR code containing:
   - `ticketId`: Unique ticket identifier
   - `eventId`: Event identifier
   - `holder`: Ticket holder's wallet address
   - `timestamp`: Ticket creation timestamp
   - `verificationCode`: Unique verification code

3. Encrypts this data using Seal protocol and stores it on Walrus

```javascript
const qrData = {
  ticketId,
  eventId,
  holder: holderAddress,
  timestamp: Date.now(),
  verificationCode: generateVerificationCode(), // e.g., "8CAZBI5C"
};
```

### 2. Ticket Decryption

When a ticket holder decrypts their ticket:

1. They authenticate with their wallet (SessionKey creation)
2. Seal decrypts the encrypted metadata from Walrus
3. The QR code image is displayed containing all verification information
4. The verification code is also shown separately for manual verification

### 3. Check-In Process

#### Authorization

Only authorized personnel can perform check-ins:
- Event organizer (creator)
- Event administrators (added via access control)

#### Scanning Flow

1. **Organizer opens Check-In Scanner**
   - Navigate to event detail page
   - Click "Check-In Attendees" button
   - System verifies organizer authorization

2. **Scan Attendee QR Code**
   - Attendee shows their decrypted ticket
   - Organizer scans the QR code
   - System extracts and validates QR data

3. **Verification & Check-In**
   ```javascript
   // System validates:
   - QR code format is correct
   - Ticket belongs to this event
   - Ticket status is VALID (not used/revoked)
   - Verification code matches (stored on-chain)
   ```

4. **On-Chain Transaction**
   - Calls `attendance::record_attendance_with_verification`
   - Marks ticket as USED
   - Creates Attendance NFT
   - Transfers attendance proof to ticket holder

### 4. Smart Contract Functions

#### Main Check-In Function

```move
public entry fun record_attendance_with_verification(
    event: &EventInfo,
    user: address,
    ticket: &mut Ticket,
    verification_code: vector<u8>,
    verification_method: u8,
    clock: &Clock,
    ctx: &mut TxContext
)
```

**Parameters:**
- `event`: Event information object
- `user`: Ticket holder's address
- `ticket`: Mutable reference to ticket NFT
- `verification_code`: Code from QR code for audit trail
- `verification_method`: 1 = QR Code Scan
- `clock`: System clock for timestamp
- `ctx`: Transaction context

**Validations:**
1. Caller is event organizer
2. Ticket status is VALID
3. Ticket owner matches user address
4. Ticket belongs to this event

**Actions:**
1. Marks ticket as USED (status = 1)
2. Creates Attendance record with:
   - Event ID
   - User address
   - Ticket ID
   - Check-in timestamp
   - Verification code (for audit)
   - Verifier address (who performed check-in)
3. Transfers Attendance NFT to user

### 5. Verification Code Purpose

The verification code serves multiple purposes:

1. **Authenticity Verification**
   - Proves the QR code was generated by the system
   - Prevents fake tickets with guessed data

2. **Audit Trail**
   - Stored in Attendance record on-chain
   - Links encrypted ticket data to on-chain attendance
   - Enables post-event verification

3. **Manual Verification**
   - Displayed separately from QR code
   - Can be read out loud for verification
   - Backup method if scanner fails

4. **Offline Capability**
   - Organizer can record codes offline
   - Batch process check-ins later
   - Useful for areas with poor connectivity

## Security Features

### Access Control

- **Organizer-Only**: Only event creator can check in attendees
- **Future Enhancement**: Add role-based access for admins/verifiers

### Ticket Validation

- **Status Check**: Prevents double check-in (used tickets)
- **Event Match**: Ensures ticket is for correct event
- **Owner Verification**: Confirms ticket holder identity

### Anti-Fraud

- **Encryption**: QR data encrypted until holder decrypts
- **Unique Codes**: Each ticket has unique verification code
- **On-Chain Record**: All check-ins recorded immutably
- **Timestamp**: Prevents replay attacks

## User Flows

### For Event Organizers

1. Create event ‚Üí Get event ID
2. Navigate to event detail page
3. Click "üé´ Check-In Attendees" button
4. Grant camera permissions
5. Scan attendee QR codes
6. View success/error messages
7. Continue scanning or stop

### For Attendees

1. Purchase ticket ‚Üí Receive NFT
2. View ticket in "My Tickets"
3. Click "View Ticket" ‚Üí See ticket details
4. Click "üîì Decrypt & View Ticket"
5. Approve wallet signature
6. View decrypted details including:
   - Event location
   - Start time
   - **Verification code** (e.g., "8CAZBI5C")
   - **Entry QR code**
7. Show QR code to organizer at venue

## API Reference

### Frontend Components

#### CheckInScanner Component

Location: `/frontend/web/src/pages/events/CheckInScanner.jsx`

**Props:**
- None (uses URL parameter `eventId`)

**Features:**
- Camera-based QR scanning
- Real-time validation
- Success/error feedback
- Automatic transaction execution

#### QR Code in TicketDetail

Location: `/frontend/web/src/pages/tickets/TicketDetail.jsx`

**Decrypted Data Display:**
- QR code image
- Verification code (large, bold)
- Event location
- Access link

### Smart Contract Modules

#### attendance.move

**New Functions:**
- `record_attendance_with_verification()` - Main check-in function
- `get_verification_code()` - Retrieves code from attendance record
- `get_checked_in_by()` - Gets verifier address

#### event_registry.move

**New Functions:**
- `is_organizer()` - Checks if address is event organizer

## Configuration

### Environment Variables

```env
VITE_PACKAGE_ID=0x...  # Deployed contract address
VITE_WALRUS_AGGREGATOR=https://aggregator.walrus-testnet.walrus.space
```

### Dependencies

```json
{
  "html5-qrcode": "^2.3.8",  // QR code scanning
  "qrcode": "^1.5.4",        // QR code generation
  "@mysten/seal": "^0.9.3"   // Encryption/decryption
}
```

## Testing

### Test Scenarios

1. **Happy Path**
   - Create event
   - Purchase ticket
   - Decrypt ticket
   - Check in attendee
   - Verify attendance NFT received

2. **Error Cases**
   - Try checking in with non-organizer account
   - Scan wrong event's ticket
   - Try double check-in (already used)
   - Scan invalid QR code

3. **Edge Cases**
   - Offline check-in
   - Camera permission denied
   - Poor lighting conditions
   - Damaged QR code

## Future Enhancements

1. **Batch Check-In**
   - Queue multiple scans
   - Batch on-chain submission
   - Reduce gas costs

2. **Admin Roles**
   - Delegate check-in authority
   - Multiple verifiers per event
   - Role-based permissions

3. **Offline Mode**
   - Record QR codes locally
   - Sync when online
   - Handle network failures

4. **Analytics**
   - Check-in rates
   - Peak times
   - Attendance patterns
   - Verifier performance

5. **Enhanced Verification**
   - Biometric verification
   - Multi-factor authentication
   - GPS location verification
   - Time-based restrictions

## Troubleshooting

### Common Issues

1. **Camera Not Working**
   - Check browser permissions
   - Try different browser
   - Use external QR scanner app

2. **Unauthorized Error**
   - Verify wallet is event organizer
   - Check correct event page
   - Reconnect wallet

3. **Invalid QR Code**
   - Ensure ticket is decrypted
   - Check screen brightness
   - Try manual code entry

4. **Transaction Failed**
   - Verify ticket not already used
   - Check wallet balance (gas)
   - Retry transaction

## Support

For issues or questions:
- GitHub Issues: [github.com/zhiming817/Attenda/issues](https://github.com/zhiming817/Attenda/issues)
- Documentation: `/docs`
- Demo Guide: `/ÊºîÁ§∫ÊåáÂçó_DEMO_GUIDE.md`
