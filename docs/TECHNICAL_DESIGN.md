# 技术设计与架构文档

版本：1.0

说明：本文件描述基于 Sui、Walrus 与 Seal 的去中心化活动与票务平台的技术设计与系统架构，包含核心组件、数据模型、主要交互流程、部署建议与安全考量。

## 目标

- 提供去中心化、可验证且可组合的活动与票务解决方案。
- 保护用户隐私：仅在必要时解密门票元数据（使用 Seal）。
- 支持链上证明（票务、出席证明）并与 Walrus 存储集成用于大容量静态/私密内容。
- 保持良好的可扩展性、可运维性和可集成性（支持 ZkLogin、邮件/钱包通知、第三方支付）。

## 高层架构概览

组件：
- 用户（钱包 / ZkLogin）
- 前端 dApp（组织者视图 + 参与者视图）
- Sui 智能合约集合（注册、票务、出席）
- Walrus（Blob 存储 + Sites）
- Seal（客户端端到端加密，用于加密 blob）
- 后端服务（可选，用于支付回调、折扣管理、通知队列）
- 支付网关与外部通知服务（电子邮件 / 推送 / 钱包通知）

ASCII 架构图（简化）：

User Wallet/ZkLogin
     |
     v
  Frontend dApp <--> Backend 服务 (optional)
     |                    |
     |                    +--> 支付网关 / 邮件/通知
     v
  Sui Smart Contracts <---> Walrus (blob存储 + Sites)
            |
            +--> Seal-encrypted blobs (元数据仅由持票人解密)

## 关键组件详述

1) 智能合约（Sui）
- EventRegistry 合约：创建/更新活动的 on-chain 索引（指向 Walrus 上的元数据）。
- TicketNFT 合约：铸造门票 NFT，NFT 元数据包含最小可验证字段（token id、issuer、owner、walrus_blob_ref、加密标识符）。
- Attendance 合约：用于记录出席事件与铸造 Attendance NFT（可选择 Soulbound）。
- AccessControl 与验证模块：处理组织者权限、审批流程以及特殊票务逻辑（转让限制、黑名单等）。

设计要点：
- 合约只保存必要的可验证信息以降低链上成本，详细或私密数据应存 Walrus（加密）。
- 合约接口应包含可验证的时间戳与事件状态变更记录（创建、暂停、关闭）。

2) Walrus 存储与 Sites
- 用途：托管活动的富媒体内容、门票的加密 blob（包括 ICS、二维码图像、活动议程等）。
- 数据组织：每个活动在 Walrus 上对应一个目录/site，门票对应单独的 blob（由 Seal 加密）。
- 可通过 walrus_blob_ref（URI）在 NFT metadata 中引用。

3) Seal 加密
- 用途：对门票的敏感元数据进行端到端加密，只有持票者可解密。
- 流程：
  - 组织者生成门票明文（含访问链接、二维码、位置等），用 Seal 加密并上传到 Walrus，得到 blob_ref。
  - 在铸票时，NFT metadata 包含该 blob_ref 与加密策略（例如受限解密条件或基于持有者的密钥）。
  - 持票者通过钱包/客户端使用其私钥或 ZK 认证交换中间秘钥以解密 blob。

4) 身份与登录（ZkLogin / 链上身份）
- 支持两种主要身份路径：直接钱包签名（on-chain address）或 ZkLogin（更低侵入的隐私-preserving 登录）。
- 注册流程应将身份与可验证证据关联到注册记录（例如注册交易或零知识证明的验证记录）。

5) 前端 dApp
- 组织者视图：创建活动、上传 Walrus 内容、设置票种/价格/审批/折扣、查看报告与导出匿名化数据。
- 参与者视图：浏览活动、通过 ZkLogin 或钱包注册、查看加密门票（解密后）、出示入场二维码、接收通知。

6) 可选后端服务
- 目的：处理第三方支付回调、生成折扣码、批量通知、导出 CSV、任务队列（例如延迟铸造、邮件发送）。
- 注意：核心验证与账本应保留在链上，后端仅作辅助并尽量无状态。

## 数据模型（概念）

- Event
  - id: on-chain id
  - walrus_site_ref: string (Walrus site URL)
  - organizer: address
  - metadata: minimal on-chain索引（其余放 Walrus）

- Ticket NFT metadata (on-chain minimal):
  - token_id
  - issuer
  - owner
  - walrus_blob_ref
  - encrypted_meta_hash (用于可验证性)

- Walrus Blob (加密后存储):
  - fields: event_location, QR_code_payload, access_link, ICS_file (可选), seat_info
  - encryption: Seal 加密（两端或多方密钥交换机制）

## 主要交互流程

1) 活动创建（组织者）
  - 组织者登录前端 -> 填写活动元数据并上传富媒体到 Walrus（公开部分可直接存储）。
  - 设置票种 -> 为每张票生成加密元数据并上传 Seal 加密的 blob -> 在链上调用 EventRegistry 创建活动并记录 walrus_site_ref。

2) 用户报名与门票铸造
  - 用户使用 ZkLogin 或钱包进行身份验证。
  - 前端调用合约执行报名/购买逻辑（必要时通过后端完成支付回调）。
  - 合约在成功支付/确认后铸造 TicketNFT，并在 metadata 中嵌入 walrus_blob_ref。
  - 用户收到 NFT，客户端可使用密钥交换或 ZK 验证以解密对应的 Walrus blob 并查看完整门票信息。

3) 入场验证与出席记录
  - 入口处扫描 QR 或钱包地址 -> 客户端/门禁系统验证 NFT 持有与状态（未被撤销、未被转售限制等）。
  - 验证成功触发链上出席事件（或后端提交出席交易），合约 mint Attendance NFT（可选 soulbound）。
  - 出席事件在链上留下证明，可被用于后续空投或统计。

4) 后期数据导出与匿名化
  - 组织者可导出匿名化出席数据（仅统计与汇总，不包含可识别信息），用于分析与税务报告。

## 安全性设计要点

- 最小权限原则：合约与后端仅保存必要信息，私密数据加密存储在 Walrus。
- 加密与密钥管理：使用 Seal 提供端到端加密；密钥交换流程应避免将私钥或敏感密钥上链或上传到非受信存储。
- 防止重放与伪造：所有关键链上操作均需包含时间戳与交易原始数据签名以供验证。
- 访问控制：组织者操作需签名并在合约中验证；审批流程记录在链上以便审计。
- 智能合约安全：遵循 Sui 最佳实践、进行形式化审计或至少第三方审计，防止重入、越权与逻辑漏洞。

## 可扩展性与性能

- 将大量静态或富媒体内容放在 Walrus，链上仅保留索引与最小验证数据，以降低链上成本。
- 使用事件驱动的后端队列处理异步任务（邮件、折扣码批量发放、延迟铸造）。
- 针对高并发售票：可采用排队系统或分布式订单簿，先在后端排队并在链上分批提交交易以降低 gas 冲突。

## 部署与运维

- 合约部署：使用 Sui 的标准部署流程，保持合约版本化并在不同环境（dev/staging/prod）部署。
- Walrus Sites：为每个活动创建独立 site，托管活动页面与受限 blob。
- CI/CD：
  - 合约：编译、静态分析、单元测试、集成测试、审计后自动部署到指定环境。
  - 前端：分支构建、自动化测试、构建产物部署到 Walrus Sites（或 CDN）。

## 测试策略

- 单元测试：合约的核心逻辑（铸造、转移控制、出席铸造）应有覆盖。
- 集成测试：模拟报名到铸票到出席的完整流程，包含 Walrus blob 上传与 Seal 解密流程的端到端测试。
- 安全测试：合约审计、模糊测试与权限滥用测试。

## 隐私与合规

- 用户数据最小化：仅在必要时收集可识别信息；组织者导出数据前需提供匿名化选项。
- 法规：需考虑地区税务与数据保护法规（如 GDPR），提供删除/撤销访问的机制（Walrus blob 删除或撤销访问）。

## 交付与验收标准

- 文档：完整技术设计与部署手册（本文件 + 部署脚本说明）。
- 合约：通过单元测试与集成测试，满足基本安全审计准则。
- 前端：组织者与参与者关键流程（创建活动、报名、解密门票、入场验证）可在 staging 环境端到端运行。
- 集成：完成 Walrus 与 Seal 的端到端集成演示。

## 后续建议与路线图

- 第一期（MVP）：活动创建、票务铸造、Walrus 加密 blob、基础入场验证与出席 NFT。
- 第二期：折扣码、审批流、支付多网关集成、批量导出与更完善的通知系统。
- 第三期：社交/网络功能、基于出席的扩展激励（空投、忠诚计划）、多会场与高级报表。

---

维护者：Event-Sui 项目组
如需进一步细化（例如合约函数签名、API 规范或数据库模式），我可以继续补充并生成详细设计文档或 Swagger/OpenAPI 规范。
